###############################################################################
###  ATARI-ST VT52/VT100/ANSI-TERMINAL-EMULATOR  V.3.0C (c) Markus Hoffmann ###
###                  Kommandos, die in der Version                          ###
###                       3.0C eingebaut sind                               ###
###############################################################################

Der Bildschirm besteht aus 80*25 Zeichen. Es stehen 3 ZeichensÑtze zur Ver-
fÅgung, auûerdem wird der Drucker unterstÅtzt. 6 Textattribute und 64 ver-
schiedene Kombinationen sind mîglich. VerÑnderbarer Grafik-Font.
Korrekte Tastaturbelegung.

1) 1-Byte-Commandos:

00 NUL     ---- wird nicht - wie sonst - ignoriert, sondern es wird das
                Zeichen mit ASCII=0 ausgegeben
07 BELL    ---- Glockenton

08 BACKSPACE -- Cursor 1 Spalte nach links, am Rand stoppen

09 TAB     ---- nÑchste Horizontale Tabulatorposition anspringen

10 LINEFEED --- gehe in nÑchste Zeile, selbe Spalte oder gehe in nÑchste 
		Zeile, erste Spalte (je nach linefeed-/newline-mode)
12 FORMFEED --- Bildschirm: siehe LINEFEED, Drucker: Seite auswerfen

13 CR      ---- gehe an den Anfang der Zeile (RETURN)

14 CTRL-N  ---- IBM-Standart-Zeichensatz wÑhlen
  
15 CTRL-O  ---- ATARI-ST-Zeichensatz wÑhlen

16 CTRL-P  ---- Grafik-Zeichensatz wÑhlen

24 CAN     ---- Unterbricht eine Escape-sequenz

26 SUB     ---- wie CAN

27 ESC     ---- leitet eine Steuersequenz ein

127 DEL    ---- wird nicht - wie Åblich - ignoriert, sondern es wird
		die Delete char Funktion ausgefÅhrt (Zeichen unter dem
		Cursor lîschen, Rest der Zeile rÅckt auf.)

2) Escape-Sequenzen

ESC-c    VT100: Terminal-RESET: Emulation geht in Ausgangszustand
         VT52:  (keine Funktion)
ESC-d    Screen bis Cursor lîschen
ESC-e    Cursor einschalten
ESC-f    Cursor ausschalten
ESC-l    Aktuelle Cursorzeile lîschen
ESC-o    Zeile bis Cursor lîschen
ESC-p    INVERSE-Vedeomode on
ESC-q    INVERSE-Vedeomode off
ESC-v    Zeilenwrap ein (Cursor springt automatisch in nÑchste Zeile)
ESC-w    Zeilenwrap aus (Cursor bleibt an Ende der Zeile stehen)
ESC-A    Cursor 1 Zeile hoch, oben stoppen
ESC-B    Cursor 1 Zeile runter, unten stoppen
ESC-C    Cursor 1 Spalte rechts, am Rand stoppen
ESC-D    VT100: Cursor 1 Zeile runter, unten Bildschirm hochscrollen
         VT52:  Cursor 1 Spalte links, am Rand stoppen
ESC-E    Vt100: Entspricht CR+LF (Cursor an den Anfang der nÑchsten Zeile)
         Vt52 : Screen lîschen/Terminal reset
ESC-H    VT100: Horizontalen Tabulator in Cursorspalte setzten
         VT52:  Cursor Home
ESC-I    Cursor 1 Zeile nach oben, oben runterscrollen
ESC-J    VT100: Vertikal Tabulator in Cursorzeile setzen
         VT52:  Screen ab Cursor lîschen
ESC-K    Lîsche bis zum Ende der Zeile
ESC-L    1 Zeile einfÅgen
ESC-M    VT100: Cursor 1 Zeile hoch, oben Bildschirm runterscrollen
         VT52:  Zeile entfernen
ESC-N    Font 0 (IBM) nur fÅr nÑchstes Zeichen einschalten
ESC-O    Font 1 (ATARI) nur fÅr nÑchstes Zeichen einschalten
ESC-P    Font 2 (GRAFIK) nur fÅr nÑchstes Zeichen einschalten
ESC-Y <pl+32> <pc+32>   Cursor Positionieren (VT52)
ESC-Z	 Erfragt Terminaltyp
ESC-7    Cursorposition speichern
ESC-j    Cursorposition speichern
ESC-8    Cursor zur gespeicherten Position
ESC-k    Cursor zur gespeicherten Position
ESC-<    VT52-Modus verlassen, VT100 einschalten 
ESC-[    ---> Weitere Parameter folgen
ESC-#     "
ESC-(     "
ESC-)     "

3) Mehrbyte und Dez-Paramerter-Kommandos

bp = Variabler Wert in Dezimal als Zeichenkette(!) 0-255
     also z.B. '1','4','6' (3 Bytes) fÅr den Wert 146
     oder      '0','0','1' (3 Bytes) fÅr den Wert 1
     oder      '1'         (1 Byte ) fÅr den Wert 1
mehrere Werte werden durch das Semikolon (';') getrennt.

Die mit * gekennzeichneten Werte kînnen auch weggelassen werden.
Wird sonst ein Wert weggelassen (auûer bei ESC-[-z), rechnet das Programm
mit dem Wert 1.

xp = entspricht bp   (X-Position)
yp = entspricht bp   (Y-Position)

Die Spalten und Zeilen beginnen je mit der Nummer 1

bs = mehrere Werte bp hintereinander, die durch ein Semikolon (';') getrennt
     sind.

ESC-[-bp-A       Cursor um bp Zeilen hoch. Oben stoppen.
ESC-[-bp-B       Cursor um bp Zeilen nach unten. Unten stoppen.
ESC-[-bp-C       Cursor um bp Spalten nach rechts. Am Rand stoppen.
ESC-[-bp-D       Cursor um bp Spalten nach links. Am Rand stoppen.
ESC-[-yp-;-xp-H  Cursor positionieren yp=Zeile, xp=Spalte
ESC-[-H          Cursor Home
ESC-[-bp-I       bp mal H-TAB ausfÅhren
ESC-[-bp-J       je nach bp bestimmte Bereiche auf dem Bildschirm lîschen:

  *   bp = 0     Screen ab Cursor lîschen
      bp = 1     Screen bis Cursor lîschen
      bp = 2     Ganzen Screen lîschen


ESC-[-bp-K       je nach bp bestimmte Bereiche innerhalb einer Zeile lîschen:
    
  *   bp = 0     Zeile ab Cursor lîschen
      bp = 1     Zeile bis Cursor lîschen
      bp = 2     Ganze Zeile lîschen

ESC-[-bp-L       bp Zeilen einfÅgen
ESC-[-bp-M       bp Zeilen lîschen  (DEL)
ESC-[-bp-P       bp Zeichen lîschen (DEL)
ESC-[-bp-Y       bp mal Vertical-Tab auslîsen
ESC-[-bp-Z       bp mal Tab rÅckwÑrts
ESC-[-0-c        Erfragt Terminaldevice (Antwort Åber Message-Puffer:ESC-?1;0c)
ESC-[-yp-;-xp-f  Cursorpositionierung siehe ESC-[-yp-xp-H
ESC-[-f          Cursor Home
ESC-[-bp-g       Tabulatorfunktionen:

  *   bp = 0     Tabulator in aktueller Cursorposition lîschen
      bp = 3     Alle Tabulatoren lîschen

ESC-[-bp-h       Diverse Einstellungen (+ = DEFAULT)
      ^----------statt bp auch bs !

      bp =  2    Tastatur gesperrt, es werden keine Tastendrucke mehr
		 Åber den Message-Buffer geliefert (noch keine Funktion)
      bp =  4    Insert mode (noch nicht implementiert)
  +   bp = 12    Echo aus
      bp = 20    newline mode LF,FF,VT,CR = CR-LF

ESC-[-?-bp-h     Diverse Einstellungen (+ = DEFAULT)

      bp = 1     Cursor-Tasten in Applikations-Modus (noch keine Funktion)
      bp = 3     132 Spalten Modus (nicht integriert)
      bp = 4     "weicher" Bildschirmscroll (noch nicht integriert)
  +   bp = 5     Weiûer Hintergrund, schwarze Schrift
      bp = 6     Region einschalten (noch nicht integriert)
  +   bp = 7     Zeilenwrap einschalten
  +   bp = 8     Tastatur-Autorepeat an  (noch nicht integriert)
      bp = 9     480 scan line Mode      (nicht integriert)
      bp = 18    print form feed an (nach Hardcopy, bei Autoprint)
  +   bp = 19    gesamten Bildschirm drucken (ACHTUNG: dies ist nur eine
		 Einstellung. Der Bildschirm wird erst mit ESC-[0i gedruckt.)

ESC-[-bp-i       Druckersteuerung:
      
  *   bp = 0     Der gesamte Bildschirm wird gedruckt
      bp = 1     Die Zeile, in der der Cursor steht, wird gedruckt
  +   bp = 4     print controller off
      bp = 5     print controller on (alle Zeichen werden unverÑndert auch 
		 an den Drucker gesendet.)

ESC-[-?-bp-i     Druckersteuerung:

  +   bp = 4     Autoprint off
      bp = 5     Autoprint on   (Die Zeichen werden auch gedruckt.)

ESC-[-bp-l       Diverse Einstellungen

  +   bp =  2    Tastatur frei
  +   bp =  4    Replace mode
      bp = 12    lokales Echo an (noch nicht implementiert)
  +   bp = 20    linefeed mode LF,FF,VT = LF ; CR = CR

ESC-[-?-bp-l     Diverse Einstellungen

  +   bp = 1     Cursor-Tasten in Normal-Modus
      bp = 2     ====> VT52-Emulation einschalten 
  +   bp = 3     80 Spalten Modus
  +   bp = 4     normaler Bildschirmscroll
      bp = 5     Schwarzer Hintergrund, weiûe Schrift
  +   bp = 6     Region aus, Full-screen-mode
      bp = 7     Zeilenwrap aus
      bp = 8     Tastaturrepeat aus  (funktioniert noch nicht)
      bp = 9     240 Scan-line Mode  (nicht integriert)
  +   bp = 18    print formfeed aus  (bei Autoprint/Hardcopy)
      bp = 19    nur Region drucken

ESC-[-bp-m       Schriftattribute setzen:
      
  *   bp = 0     Normal Video, Attribute ausschalten
      bp = 1     Highlight 
      bp = 2     Fettschrift
      bp = 3     Kursiv -- nicht unterstÅtzt --
      bp = 4     Unterstrichen
      bp = 5     Blinkend
      bp = 6     Grau unterlegt
      bp = 7     Invertiert
      bp = 8     Abgedunkelt -- nicht unterstÅtzt --

 bp = 21 bis 28  Entsprechendes Attribut ausschalten

ESC-[-bp-n       Request-Funktionen (Antworten Åber Messagebuffer)

      bp = 5     erfragt Statusmeldung (Antwort: ESC-[-0-n)
      bp = 6     erfragt Cursorposition (Antwort: ESC-[-pl-;-pc-R)

ESC-[-?-bp-n     Request_Funktionen

      bp = 15    Erfragt Printer-Status (Antwort: ESC-[-?-1-0-n   ready
						  ESC-[-?-1-1-n   not ready)

ESC-[-bp-q       Setzt interne LEDs: (kînnen von einigen Terminal-
                 programmen ausgewertet werden)

  *   bp = 0     alle LEDs lîschen
      bp = 1 - 7 LED Nr. bp setzten

ESC-[-tp-;-bp-r  set_region  tp= Top-line Bp = Botom-line
ESC-[-s          Cursorposition speichern
ESC-[-u          gehe zur gespeicherten Position
ESC-[-bp-;-bs-z  Neues Zeichen im Grafikzeichensatz erstellen:          

      Bp = ASCII-Code des Zeichens im Grafikfont 0-255
      bs = 16 Daten (je dezimaler Wert des Bytes mit Bitmap)

------
4) VDI-ESC-Funktionen

Åber die VDI-Esc-Funktionen (VDI Nr 5) lassen sich nun ebenfalls die
Funktionen der Emulation ansprechen. Besonders nÅtzlich sind hier aber
die Abfrage-Funktionen. Parameter werden Åber das INTIN-Array und die 
RÅckgabewerte Åber das INTOUT-Array Åbergeben (jeweils Words).

   id     Funktion
---------------------------------------------------------------------------
    0     keine Funktion
    1     erfragt die Grîûe des Bildschirms in Spalten und Zeilen
    2     Textmode aus: Cursor off + clear screen + cursor home
    3     Textmode an:  clear screen + cursor home + cursor on
    4-7   cursor up, down, right, left
    8     cursor home
    9     Screen ab Cursorpos lîschen
   10     Zeile  ab Cursorpos lîschen
   11     Cursor positionieren
   12     Text ausgeben (als Word-String in intin)
   13,14  Inverse on, off
   15     Cursorposition erfragen
   16     Status erfragen VT100EMU liefert 7, SYSTEMVT52 liefert 1
   17     Screen-Text-Hardcopy
   18,19  show, hide Cursor
  101     Offset setzen   (keine Funktion)
  102     ZeichenGrîûe und Fontadresse festlegen (noch nicht implementiert)

-----------------------------------------------------------------------------
5) TEMUL-Standart

In der Datei VT100EMU.PRG befinden sich nach dem Programmheader (28 Bytes
bzw. nach laden und relozieren mit gemdos(75,3,...) 256 Bytes ) folgende Daten:

Offset vom Programmanfang(!)=28 Bytes nach Dateianfang bzw. 256 Bytes nach
Basepage.

  0       L      Sprungbefehl
  4       L      Adresse der Initialisierungsroutine
  8       L      Adresse des Strings: Copyrightmeldung
 12       L      Adresse der Zeichenausgaberoutine (öbergabe des ASCII-Codes
                 als Wort auf dem Stack)
 16       L      Adresse des Strings fÅr die Cursortaste Pfeil-rauf
 20       L                  "                                 runter
 24       L                  "                                 links
 28       L                  "                                 rechts
 32       4L     (reserviert)
 48       L      Adresse des Zeichen-Screen-Speichers
 52       L      Adresse einer Tabelle mit internen Variablen

Stringende sind mit 0-Byte gekennzeichnet.

Bei der Fremdinstallierung funktionieren allerdings das Cursorblinken und
die Schriftattribute 'BLINK' nicht.

Sie erkennen anhand der Systemvariable memval3 ($51A.L), ob die Emulation
bereits im System (nicht TEMUL!) installiert ist.
Ist die Emulation installiert, enthÑlt memval3 den Wert: $7777EEEE.L

Mîchten Sie mit der Emulation Dfö betreiben, so sollten Sie Das Programm
vorher starten (z.B. aus dem AUTO-Ordner) und dann ein Terminalprogramm ver-
wenden, was die TOS-Ausgaberoutine benutzt. (BIOS, GEMDOS) z.B. DESK.ACC
Da diese Programme die Cursortastenbelegung leider nicht beherrschen, liegt
ein kurzes Listing in Gfa-Basic anbei, was selbst ein MINI-Terminalprogramm
darstellt.

6)  Message-puffer (ab Version 2.0C)

Es wurden nun auch die ANSI-Abfrage-Funktionen integriert. Die Antworten auf 
die Abfragen werden von der Emulation in einen 256 Bytes groûen Ringbuffer
geschrieben. Der Ringbuffer kann byteweise ausgelesen werden mit der BIOS-
Funktion bconin(5) (ASS: BIOS(2,5) Gfa: INP(5)). Mit bconstat(5) 
(BIOS(1,5), INP?(5)) kann wie Åblich erfragt werden, ob auch Daten da sind.
Es sollte grundsÑtzlich nicht versucht werden, ein Byte zu lesen, wenn der
Buffer leer ist ( bconstat(5)=0 ).

Beispiel: Die Emulation erhÑlt den Befehl
          ESC-[-c   (Terminaltyp erfragen)
          danach befinden sich im Messagebuffer 7 Bytes:
          "ESC [ ? 1 ; 0 c"   (Terminaltyp Vt100)

7) Tastaturbelegungen


Geplant ist noch die VT100/ANSI-Typische Tastaturbelegung. Hierbei soll
sich nach einem Tastendruck (z.b. Cursortaste) dann im Messagepuffer
der entsprechende String z.b. ESC-[-A befinden.

Hierbei gibt es aber noch ungeahnte Probleme, so daû ich dieses Projekt auf
weitere Versionen verschieben muû.
